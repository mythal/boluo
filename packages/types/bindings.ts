// This file has been generated by Specta. DO NOT EDIT.

export type AddChannelMember = { channelId: string; userId: string; characterName?: string };

export type AppSettings = {
  mediaUrl?: string | null;
  appUrl?: string | null;
  siteUrl?: string | null;
  sentryDsn?: string | null;
};

export type BasicInfo = { version: string };

export type Binary = { l: ExprNode; r: ExprNode; op: Operator };

export type BinaryResult = {
  op: Operator;
  l: EvaluatedExprNode;
  r: EvaluatedExprNode;
  value: number;
};

export type Channel = {
  id: string;
  name: string;
  topic: string;
  spaceId: string;
  created: string;
  isPublic: boolean;
  defaultDiceType: string;
  defaultRollCommand: string;
  isDocument: boolean;
  type: ChannelType;
  isArchived?: boolean;
};

export type ChannelMember = {
  userId: string;
  channelId: string;
  joinDate: string;
  characterName: string;
  textColor: string | null;
  isMaster: boolean;
};

export type ChannelMemberWithUser = { member: ChannelMember; user: User };

export type ChannelMembers = {
  members: MemberWithUser[];
  colorList: { [key in string]: string };
  heartbeatMap: { [key in string]: number };
  selfIndex: number | null;
};

export type ChannelType = 'IN_GAME' | 'OUT_OF_GAME' | 'DOCUMENT';

export type ChannelWithMaybeMember = { channel: Channel; member: ChannelMember | null };

export type ChannelWithMember = { channel: Channel; member: ChannelMember };

export type ChannelWithRelated = {
  channel: Channel;
  members: MemberWithUser[];
  space: Space;
  colorList: { [key in string]: string };
  heartbeatMap: { [key in string]: number };
};

export type Character = {
  id: string;
  name: string;
  description: string;
  color: string;
  alias: string | null;
  imageId: string | null;
  spaceId: string;
  ownerId: string;
  visibility: CharacterVisibility;
  isArchived: boolean;
  metadata: JsonValue;
  created: string;
  modified: string;
};

export type CharacterVariable = {
  key: string;
  characterId: string;
  displayName: string;
  alias: string[];
  sort: number;
  trackHistory: boolean;
  value: JsonValue;
  metadata: JsonValue;
  created: string;
  modified: string;
};

export type CharacterVariableHistory = {
  id: string;
  operatorId: string | null;
  characterId: string;
  reason: JsonValue | null;
  key: string;
  value: JsonValue;
  created: string;
};

export type CharacterVisibility = 'PRIVATE' | 'PUBLIC';

export type CheckChannelName = { spaceId: string; name: string };

/**
 * Query params for checking name/alias availability.
 */
export type CheckCharacterName = { spaceId: string; name?: string | null; alias?: string | null };

export type CheckEmailExists = { email: string };

export type CheckResult<T> = { type: 'Ok'; value: T } | { type: 'Error'; message: string };

export type CheckUsernameExists = { username: string };

/**
 * Query params for checking variable key/alias availability.
 */
export type CheckVariableAvailability = {
  characterId: string;
  key?: string | null;
  alias?: string[];
};

export type ChildText = { type: 'Text' } & Span;

export type ClientEvent =
  | { type: 'PREVIEW'; preview: PreviewPost }
  | { type: 'DIFF'; preview: PreviewDiffPost }
  | { type: 'STATUS'; kind: StatusKind; focus: string[] };

export type CocRoll = { subType: CocRollSubType; target?: PureExprNode | null };

export type CocRollResult = CocRoll & {
  targetValue?: number | null;
  value: number;
  rolled: number;
  modifiers: number[];
};

export type CocRollSubType = 'NORMAL' | 'BONUS' | 'BONUS_2' | 'PENALTY' | 'PENALTY_2';

export type ConfirmEmailChange = { token: string };

export type ConnectionError =
  | 'CURSOR_TOO_OLD'
  | 'NO_PERMISSION'
  | 'UNAUTHENTICATED'
  | 'INVALID_TOKEN'
  | 'UNEXPECTED'
  | 'BAD_REQUEST';

export type ConnectionState = {
  rtt_ms: number;
  /**
   * Connection count in the pool.
   *
   * Always 1 if the connection is not pooled.
   */
  count: number;
  idle: number;
};

export type CreateChannel = {
  spaceId: string;
  name: string;
  characterName?: string;
  defaultDiceType: string | null;
  isPublic: boolean;
  type: ChannelType | null;
};

/**
 * Payload for creating a character.
 */
export type CreateCharacter = {
  spaceId: string;
  name: string;
  description?: string;
  color?: string;
  alias: string | null;
  imageId: string | null;
  visibility: CharacterVisibility;
  isArchived?: boolean;
  metadata: JsonValue | null;
};

/**
 * Payload for creating a note.
 */
export type CreateNote = {
  spaceId: string;
  type: NoteType;
  title?: string;
  keywords?: string[];
  content?: string;
  visibility: NoteVisibility;
  visibleTo?: string[];
  everyoneCanEdit?: boolean;
  trackHistory?: boolean;
};

export type CreateSpace = {
  name: string;
  password: string | null;
  description: string;
  defaultDiceType: string | null;
  firstChannelName: string;
  firstChannelType: ChannelType | null;
};

/**
 * Payload for creating a character variable.
 */
export type CreateVariable = {
  characterId: string;
  key: string;
  displayName?: string;
  alias?: string[];
  sort?: number;
  trackHistory?: boolean;
  value: JsonValue;
  metadata: JsonValue | null;
};

/**
 * Payload for deleting a character variable.
 */
export type DeleteVariable = { characterId: string; key: string };

export type DicePool = {
  counter: number;
  face: number;
  min: number;
  addition: number;
  critical?: number | null;
  fumble?: number | null;
};

export type DicePoolResult = DicePool & { value: number; values: number[] };

export type DiscourseConnect = { sso: string; sig: string };

export type DiskInfo = { name: string; mount_point: string; available: number; total: number };

export type EditChannel = {
  channelId: string;
  name: string | null;
  topic: string | null;
  defaultDiceType: string | null;
  defaultRollCommand: string | null;
  grantMasters?: string[];
  removeMasters?: string[];
  isPublic: boolean | null;
  isDocument: boolean | null;
  isArchived: boolean | null;
  type: ChannelType | null;
};

export type EditChannelMember = {
  channelId: string;
  characterName: string | null;
  textColor: string | null;
};

export type EditChannelTopic = { channelId: string; topic: string };

/**
 * Payload for editing a character; `alias: Some("")` clears it.
 */
export type EditCharacter = {
  characterId: string;
  name: string | null;
  description: string | null;
  color: string | null;
  alias: string | null;
  imageId: string | null;
  visibility: CharacterVisibility | null;
  isArchived: boolean | null;
  metadata: JsonValue | null;
};

export type EditMessage = {
  messageId: string;
  name: string;
  text: string;
  entities?: Entities;
  inGame?: boolean;
  isAction?: boolean;
  mediaId?: string | null;
  color?: string;
};

/**
 * Payload for editing a note.
 */
export type EditNote = {
  noteId: string;
  type: NoteType | null;
  title: string | null;
  keywords: string[] | null;
  content: string | null;
  visibility: NoteVisibility | null;
  visibleTo: string[] | null;
  everyoneCanEdit: boolean | null;
  trackHistory: boolean | null;
};

export type EditSpace = {
  spaceId: string;
  name: string | null;
  description: string | null;
  defaultDiceType: string | null;
  explorable: boolean | null;
  isPublic: boolean | null;
  allowSpectator: boolean | null;
  grantAdmins?: string[];
  removeAdmins?: string[];
};

export type EditUser = {
  nickname: string | null;
  bio: string | null;
  avatar: string | null;
  defaultColor: string | null;
};

/**
 * Payload for editing a character variable.
 */
export type EditVariable = {
  characterId: string;
  key: string;
  displayName: string | null;
  alias: string[] | null;
  sort: number | null;
  trackHistory: boolean | null;
  value: JsonValue | null;
  metadata: JsonValue | null;
  reason: JsonValue | null;
};

export type EmailVerificationStatus = { isVerified: boolean };

export type Entities = Entity[];

export type Entity =
  | ({ type: 'Text' } & Span)
  | ({ type: 'Link' } & LinkEntity)
  | ({ type: 'Code' } & SpanWithChild)
  | ({ type: 'CodeBlock' } & SpanWithChild)
  | ({ type: 'Strong' } & SpanWithChild)
  | ({ type: 'Emphasis' } & SpanWithChild)
  | ({ type: 'StrongEmphasis' } & SpanWithChild)
  | ({ type: 'Expr' } & ExprEntity);

export type EvaluatedExprNode =
  | ({ type: 'Roll' } & RollResult)
  | ({ type: 'Binary' } & BinaryResult)
  | { type: 'Num'; value: number }
  | { type: 'Max'; node: RollResultNode; value: number }
  | { type: 'Min'; node: RollResultNode; value: number }
  | ({ type: 'SubExpr' } & SubExprResult)
  | ({ type: 'CocRoll' } & CocRollResult)
  | ({ type: 'FateRoll' } & FateResult)
  | ({ type: 'DicePool' } & DicePoolResult)
  | ({ type: 'Repeat' } & RepeatResult)
  | { type: 'Unknown'; value: number };

export type EventId = {
  /**
   * The timestamp in milliseconds
   * The value will not exceed 2^53 - 1, which is safe for JavaScript
   */
  timestamp: number;
  /**
   * Every start up will allocate a new node id. 0 is reserved for single node
   * environment or client.
   */
  node: number;
  seq: number;
};

export type Export = { channelId: string; after?: string | null };

export type ExprEntity = Span & { node: ExprNode };

export type ExprNode =
  | ({ type: 'Roll' } & Roll)
  | ({ type: 'Binary' } & Binary)
  | { type: 'Num'; value: number }
  | { type: 'Max'; node: RollNode }
  | { type: 'Min'; node: RollNode }
  | { type: 'SubExpr'; node: ExprNode }
  | ({ type: 'CocRoll' } & CocRoll)
  | ({ type: 'DicePool' } & DicePool)
  | { type: 'FateRoll' }
  | ({ type: 'Repeat' } & Repeat)
  | { type: 'Unknown' };

export type FateResult = { value: number; values: [number, number, number, number] };

export type GetMe = {
  user: User;
  settings: JsonValue;
  myChannels: ChannelWithMember[];
  mySpaces: SpaceWithMember[];
};

export type GetMessagesByChannel = {
  channelId: string;
  before: number | null;
  limit: number | null;
};

export type GrantOrRemoveChannelMaster = {
  channelId: string;
  userId: string;
  grantOrRevoke: GrantOrRevoke;
};

export type GrantOrRevoke = 'GRANT' | 'REVOKE';

export type HealthCheck = {
  redis: CheckResult<ConnectionState>;
  database: CheckResult<ConnectionState>;
};

export type Href = string | Span;

export type JoinChannel = { channelId: string; characterName?: string };

export type JoinSpace = { spaceId: string; token: string | null };

export type JsonValue =
  | null
  | boolean
  | number
  | string
  | JsonValue[]
  | { [key in string]: JsonValue };

export type KickFromChannel = { spaceId: string; channelId: string; userId: string };

export type KickFromSpace = { spaceId: string; userId: string };

export type LinkEntity = Span & { href: Href; child: ChildText; title?: string | null };

/**
 * Query params for listing characters in a space.
 */
export type ListCharacters = { id: string; includeArchived?: boolean };

export type Login = { username: string; password: string; withToken?: boolean };

export type LoginReturn = { me: GetMe; token: string | null };

export type MakeToken = { spaceId?: string | null; userId?: string | null };

export type Media = {
  id: string;
  mimeType: string;
  uploaderId: string;
  filename: string;
  originalFilename: string;
  hash: string;
  size: number;
  description: string;
  source: string;
  created: string;
};

export type MediaQuery = { filename: string | null; id: string | null; download?: boolean };

export type Member = { channel: ChannelMember; space: SpaceMember };

export type MemberWithUser = { channel: ChannelMember; space: SpaceMember; user: User };

export type Message = {
  id: string;
  senderId: string;
  channelId: string;
  parentMessageId?: string | null;
  name: string;
  mediaId?: string | null;
  seed: number[];
  inGame?: boolean;
  isAction?: boolean;
  isMaster?: boolean;
  pinned?: boolean;
  tags?: string[];
  folded?: boolean;
  text: string;
  whisperToUsers?: string[] | null;
  entities: Entities;
  created: string;
  modified: string;
  posP: number;
  posQ: number;
  pos: number;
  /**
   * The color of the message
   *
   * The string is not always a hex color, it can be a preset color name like "preset:orange",
   * or refer to a character's name like "char:DM".
   *
   * If the string contains a semicolon, the second part is for the dark mode.
   */
  color: string;
};

export type MessageMoveToMode = 'TOP' | 'BOTTOM';

export type MoveMessageBetween = {
  messageId: string;
  range: [[number, number] | null, [number, number] | null];
  /**
   * The original position of the message, at the time of the client sending the request.
   */
  expectPos?: [number, number] | null;
  channelId: string;
};

export type NewMessage = {
  messageId?: string | null;
  previewId?: string | null;
  channelId: string;
  name: string;
  text: string;
  entities?: Entities;
  inGame: boolean;
  isAction?: boolean;
  mediaId?: string | null;
  whisperToUsers?: string[] | null;
  pos?: [number, number] | null;
  color?: string;
};

export type Note = {
  id: string;
  type: NoteType;
  spaceId: string;
  title: string;
  keywords: string[];
  disabled: boolean;
  ownerId: string;
  content: string;
  visibility: NoteVisibility;
  visibleTo: string[];
  everyoneCanEdit: boolean;
  trackHistory: boolean;
  created: string;
  modified: string;
};

export type NoteHistory = {
  id: string;
  noteId: string;
  operatorId: string | null;
  content: string;
  created: string;
};

export type NoteType = 'TERM' | 'CHARACTER';

export type NoteVisibility = 'PRIVATE' | 'CHANNELS' | 'USERS' | 'PUBLIC';

export type Operator = '+' | '-' | 'ร' | 'รท';

export type PreSign = { filename: string; mimeType: string; size: number };

export type PreSignResult = { url: string; mediaId: string };

export type Preview = {
  id: string;
  /**
   * The version of the preview
   *
   * Every edit will increase the version.
   *
   * Start from 1.
   */
  v?: number;
  senderId: string;
  channelId: string;
  parentMessageId?: string | null;
  name: string;
  mediaId?: string | null;
  inGame?: boolean;
  isAction?: boolean;
  isMaster?: boolean;
  clear?: boolean;
  text?: string | null;
  whisperToUsers?: string[] | null;
  entities: Entities;
  pos: number;
  editFor?: string | null;
  edit?: PreviewEdit | null;
};

export type PreviewDiff = { sender: string; _: PreviewDiffPost };

export type PreviewDiffOp =
  | { type: 'SPLICE'; i: number; len: number; _: string }
  | { type: 'A'; _: string }
  | { type: 'NAME'; name: string };

/**
 * A diff to be applied to a keyframe preview
 *
 * Diff ops are a full patch relative to the referenced keyframe preview.
 *
 * Changes to fields outside text/name/entities (e.g., media_id, in_game, is_action, clear,
 * edit_for, edit) must be sent as a full Preview keyframe.
 */
export type PreviewDiffPost = {
  /**
   * Channel ID
   */
  ch: string;
  /**
   * The id of the keyframe preview that is being edited
   */
  id: string;
  /**
   * The version of the keyframe preview that this diff is based on.
   *
   * Assumes the version fits within u16 (no overflow expected).
   */
  ref: number;
  /**
   * The version of the diff
   *
   * Every edit will increase the version.
   *
   * Assumes the version fits within u16 (no overflow expected).
   */
  v?: number;
  /**
   * The modifications to be applied
   */
  op: PreviewDiffOp[];
  /**
   * Entities. If empty, the client should parse the text to regenerate entities.
   */
  xs?: Entity[];
};

export type PreviewEdit = { time: string; p: number; q: number };

export type PreviewPost = {
  id: string;
  v?: number;
  channelId: string;
  name: string;
  mediaId: string | null;
  inGame?: boolean;
  isAction?: boolean;
  text: string | null;
  clear?: boolean;
  entities: Entities;
  editFor?: string | null;
  edit?: PreviewEdit | null;
};

export type Proxy = { name: string; url: string; region: string };

export type PureBinary = { l: PureExprNode; r: PureExprNode; op: Operator };

export type PureExprNode =
  | ({ type: 'Binary' } & PureBinary)
  | { type: 'Num'; value: number }
  | { type: 'SubExpr'; node: PureExprNode }
  | ({ type: 'Repeat' } & PureRepeat)
  | { type: 'Unknown' };

export type PureRepeat = { node: PureExprNode; count: number };

export type QuerySpace = { id: string; token: string | null };

export type QueryUser = { id: string | null };

export type Register = { email: string; username: string; nickname: string; password: string };

export type Repeat = { node: ExprNode; count: number };

export type RepeatResult = Repeat & { evaluated: EvaluatedExprNode[]; value: number };

export type RequestEmailChange = { newEmail: string; lang?: string | null };

export type ResendEmailVerification = { lang?: string | null };

export type ResendEmailVerificationResult = 'ALREADY_VERIFIED' | 'SENT';

export type ResetPassword = { email: string; lang: string | null };

export type ResetPasswordConfirm = { token: string; password: string };

export type ResetPasswordTokenCheck = { token: string };

export type Roll = { face: number; counter: number; filter?: [RollFilterType, number] | null };

export type RollFilterType = 'LOW' | 'HIGH';

export type RollNode = { type: 'Roll' } & Roll;

export type RollResult = Roll & { values: number[]; filtered?: number[] | null; value: number };

export type RollResultNode = { type: 'Roll' } & RollResult;

export type SearchDirection = 'asc' | 'desc';

export type SearchFilter = 'ALL' | 'IN_GAME' | 'OUT_OF_GAME';

export type SearchMessagesParams = {
  channelId: string;
  keyword: string;
  pos?: number | null;
  direction?: SearchDirection;
  includeArchived?: boolean;
  filter?: SearchFilter;
  nameFilter?: SearchNameFilter;
};

export type SearchMessagesResult = {
  messages: Message[];
  nextPos?: number | null;
  scanned: number;
  matched: number;
};

export type SearchNameFilter = 'NAME_ONLY' | 'ALL' | 'TEXT_ONLY';

export type SearchParams = { search: string };

export type Settings = { enterSend?: boolean; expandDice?: boolean };

export type Space = {
  id: string;
  name: string;
  description: string;
  created: string;
  modified: string;
  ownerId: string;
  isPublic: boolean;
  language: string;
  defaultDiceType: string;
  explorable: boolean;
  allowSpectator: boolean;
  latestActivity: string;
};

export type SpaceMember = { userId: string; spaceId: string; isAdmin: boolean; joinDate: string };

export type SpaceMemberWithUser = { space: SpaceMember; user: User };

export type SpaceWithMember = { space: Space; member: SpaceMember; user: User };

export type SpaceWithRelated = {
  space: Space;
  members: { [key in string]: SpaceMemberWithUser };
  channels: Channel[];
  channelMembers: { [key in string]: ChannelMember[] };
  usersStatus: { [key in string]: UserStatus };
};

export type Span = { start: number; len: number };

export type SpanWithChild = Span & { child: ChildText };

export type StatusKind = 'OFFLINE' | 'AWAY' | 'ONLINE';

export type SubExprResult = { node: ExprNode; evaluatedNode: EvaluatedExprNode; value: number };

export type Token = { token: string; issuedAt: number };

export type Update = {
  mailbox: string;
  id: EventId;
  body: UpdateBody;
  /**
   * How clients should treat this update for reconnect/cursor purposes.
   */
  live?: UpdateLifetime;
};

export type UpdateBody =
  | { type: 'NEW_MESSAGE'; channelId: string; message: Message; previewId: string | null }
  | { type: 'MESSAGE_DELETED'; messageId: string; channelId: string; pos: number }
  | { type: 'MESSAGE_EDITED'; channelId: string; message: Message; oldPos: number }
  | { type: 'MESSAGE_PREVIEW'; channelId: string; preview: Preview }
  | { type: 'DIFF'; channelId: string; diff: PreviewDiff }
  | { type: 'CHANNEL_DELETED'; channelId: string }
  | { type: 'CHANNEL_EDITED'; channelId: string; channel: Channel }
  | { type: 'MEMBERS'; channelId: string; members: MemberWithUser[] }
  | { type: 'INITIALIZED' }
  | { type: 'STATUS_MAP'; statusMap: { [key in string]: UserStatus }; spaceId: string }
  | { type: 'SPACE_UPDATED'; spaceWithRelated: SpaceWithRelated }
  | { type: 'ERROR'; code: ConnectionError; reason: string; span: string }
  | { type: 'APP_UPDATED'; version: string }
  | { type: 'APP_INFO'; info: BasicInfo };

export type UpdateLifetime =
  /**
   * Transient updates are not stored in mailbox state and cannot be resumed.
   */
  | 'T'
  /**
   * Volatile updates are stored in mailbox state but are best-effort and may be replaced/pruned.
   *
   * Clients should treat them as non-resumable for cursor advancing (same as `Transient`),
   * while the server may still include the latest ones in `Update::get_from_state`.
   *
   * Clients should can safely replay them if they receive them again.
   */
  | 'V'
  /**
   * Persistent updates are stored in mailbox state and can be resumed.
   */
  | 'P';

export type UpdateQuery = {
  mailbox: string;
  token?: string | null;
  after?: number | null;
  seq?: number | null;
  node?: number | null;
  /**
   * Some clients may keep logged in state but actually failed to authenticate.
   * On client connecting, we need to check if the user ID matches the authenticated user.
   *
   * The check is optional.
   */
  userId?: string | null;
};

export type Upload = { filename: string; mimeType: string | null; size?: number };

export type User = {
  id: string;
  username: string;
  nickname: string;
  bio: string;
  joined: string;
  avatarId: string | null;
  /**
   * See `Message::color`
   */
  defaultColor: string;
};

export type UserStatus = { timestamp: number; kind: StatusKind; focus: string[] };

/**
 * Query params for listing variable history by key.
 */
export type VariableHistoryQuery = { characterId: string; key: string };

export type VerifyEmail = { token: string };
